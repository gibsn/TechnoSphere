Задание 2: чат.
Что хочется получить.
Сервер
Чат-сервер принимает сообщения от клиента и рассылает его всем своим клиентам (включая отправившего). Сервер работает по протоколу TCP (порт 3100). Исполняемый файл должен называться 'chatsrv'.

Сервер должен использовать epoll/kqueue для мультиплексирования и не блокироваться на отправке сообщений (один медленный клиент не тормозит весь чат). Сервер не должен создавать потоки исполнения/дочерние процессы.

Сообщения разделяются переводом строки ('\n'). Сообщение нужно отправлять атомарно: нужно избегать, случаев, когда сообщения перемешиваются и вместо двух сообщений "AB" и "CD" от разных клиентов будет отправлено, например, "ACD\nB\n".

Максимальная длина сообщения — 1024 байта. Большие сообщения нужно разбивать по 1024 байта и отправлять по частям.

Клиентам будут отправляться только сообщения, которые были отправлены после его подключения, история чата не ведется. При подключении клиенту выдается сообщение-приветствие, начинающееся с "Welcome".

Для тестирования необходимо, чтобы сервер производил следующее логирование: 
"accepted connection" при приеме соединения от клиента
"connection terminated" при отключении клиента от сервера
текст сообщения при его получении

Логирование должно производиться на stdout. Указанные сообщения должны содержаться в строке, но у строки лога при этом могут быть любые префиксы/суффиксы.

Серверу необходимо включить опцию SO_REUSEADDR на слушающем сокете. Сервер не должен потреблять 100% CPU при неактивности.
Клиент
Клиент для чата должен быть реализован при помощи select или poll. Клиент реализует описанный выше протокол.
Последовательность действий.
Задание можно (но не обязательно) выполнять в следующей последовательности:

Обработка входящих соединений. Программа умеет принимать (и логировать) входящее соединение.

Чтение. Программа умеет читать сообщения по одному из клиентского сокета и логировать их в stdout.

Обработка завершения соединений. Программа корректно обрабатывает закрытие соединения (и освобождает ресурсы) и логирует этот факт в stdout.

Приветствие. При подключении, в клиентский сокет пишется приветствие.

Эхо. Сообщение от клиента отправляется ему самому.

Доставка сообщений. Сообщения доставляются остальным клиентам.

Для каждого задания есть небольшой набор тестов: для запуска тестов для каждого пункта нужно выполнить 'python test.py Test<N>', где '<N>' – номер сответствующего пункта. Для запуска всех тестов нужно выполнить 'python test.py'.

В начале файла test.py можно исправить IP/порт на котором слушает сервер и имя исполняемого файла, который нужно запускать.
Дополнительные задания.
В качестве дополнительного задания, можно добавить к каждому сообщению префикc, содержащий IP отправителя, например "127.0.0.1: ".

Также, для того, чтобы сервер выдерживал работу в реальных условиях, можно научиться: отключать клиентов по таймауту и/или переполнению буфера.
Полезная информация.
Утилита lsof покажет все открытые дескрипторы и краткое их состояние. Она может быть полезна, например, для проверки закрытия дескриптора после закрытия соединения.

Утилита netcat (команда nc) позволяет выполнить tcp-соединение и писать/читать из него без написания дополнительного кода. Ее можно использовать в качестве тестового клиента.

throw std::system_error(errno, std::system_category()) выкидывает исключения с читаемым кодом ошибки, основанном на значении errno. Работает в c++11 и позволит сэкономить немного строк кода на обработки ошибок из сокета.

Поля структуры sockaddr_in должны быть в network byte order, см. функции htons/htonl.

Если сказать "using namespace std", то возможны конфликты имен: например, в качестве bind может использоваться std::bind, а не ::bind. Для вызова можно использовать полностью квалифицированное имя "::bind".

Стереть последнюю строку в терминале можно при помощи набора escape-последовательностей UP="\x1b[1A" и ERASE_LINE="\x1b[2K"
Где брать тесты и куда/как сдавать.
Сдавать нужно Makefile и все необходимые исходные файлы. В исходном файле нужно в комментариях написать используемую архитектуру (Mac OS X/Linux). 

Файлы нужно закоммитить в личный репозиторий в папку p2.

Тесты можно взять из репозитория на github: https://github.com/rvncerr/sfera-mail-mt/tree/master/practice
